var forge = require('../js/forge');
var fs = require('fs');
var http = require('http');
//var rdf = require('./rdflib');
var sys = require('sys');
var urllib = require('url');
var ws = require('./ws');

// remove xmlns from input
var normalizeNs = function(input, ns) {
  var rval = null;

  // primitive
  if(typeof input === 'string' ||
    typeof input === 'number' ||
    typeof input === 'boolean') {
    rval = input;
  }
  // array
  else if(forge.util.isArray(input)) {
    rval = [];
    for(var i = 0; i < input.length; ++i) {
      rval.push(normalizeNs(input[i], ns));
    }
  }
  // object
  else {
    if('@' in input) {
      // copy namespace map
      var newNs = {};
      for(var key in ns) {
        newNs[key] = ns[key];
      }
      ns = newNs;

      // update namespace map
      for(var key in input['@']) {
        if(key.indexOf('xmlns:') === 0) {
          ns[key.substr(6)] = input['@'][key];
        }
      }
    }

    rval = {};
    for(var key in input) {
      if(key.indexOf('xmlns:') !== 0) {
        var value = input[key];
        var colon = key.indexOf(':');
        if(colon !== -1) {
          var prefix = key.substr(0, colon);
          if(prefix in ns) {
            key = ns[prefix] + key.substr(colon + 1);
          }
        }
        rval[key] = normalizeNs(value, ns);
      }
    }
  }

  return rval;
};

// gets public key from WebID rdf
var getPublicKey = function(data, uri, callback) {
  // FIXME: use RDF library to simplify code below
  //var kb = new rdf.RDFParser(rdf.IndexedFormula(), uri).loadBuf(data);
  //var CERT = rdf.Namespace('http://www.w3.org/ns/auth/cert#');
  //var RSA  = rdf.Namespace('http://www.w3.org/ns/auth/rsa#');
  var RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
  var CERT = 'http://www.w3.org/ns/auth/cert#';
  var RSA  = 'http://www.w3.org/ns/auth/rsa#';
  var desc = RDF + 'Description';
  var about = RDF + 'about';
  var type = RDF + 'type';
  var resource = RDF + 'resource';
  var publicKey = RSA + 'RSAPublicKey';
  var modulus = RSA + 'modulus';
  var exponent = RSA + 'public_exponent';
  var identity = CERT + 'identity';
  var hex = CERT + 'hex';
  var decimal = CERT + 'decimal';

  // gets a resource identifer from a node
  var getResource = function(node, key) {
    var rval = null;

    // special case 'about'
    if(key === about) {
      if('@' in node && about in node['@']) {
        rval = node['@'][about];
      }
    }
    // any other resource
    else if(
       key in node &&
       typeof node[key] === 'object' && !forge.util.isArray(node[key]) &&
       '@' in node[key] && resource in node[key]['@']) {
      rval = node[key]['@'][resource];
    }

    return rval;
  };

  // parse XML
  uri = urllib.parse(uri);
  var xml2js = require('./xml2js');
  var parser = new xml2js.Parser();
  parser.addListener('end', function(result) {
    // normalize namespaces
    result = normalizeNs(result, {});

    // find grab all public keys whose identity matches hash from uri
    var keys = [];
    if(desc in result) {
      // normalize RDF descriptions to array
      if(!forge.util.isArray(result[desc])) {
        desc = [result[desc]];
      }
      else {
        desc = result[desc];
      }

      // collect properties for all resources
      var graph = {};
      for(var i = 0; i < desc.length; ++i) {
        var node = desc[i];
        var res = {};
        for(var key in node) {
          var obj = getResource(node, key);
          res[key] = (obj === null) ? node[key] : obj;
        }
        graph[getResource(node, about) || ''] = res;
      }

      // for every public key w/identity that matches the uri hash
      // save the public key modulus and exponent
      for(var r in graph) {
        var props = graph[r];
        if(identity in props &&
          type in props &&
          props[type] === publicKey &&
          props[identity] === uri.hash &&
          modulus in props &&
          exponent in props &&
          props[modulus] in graph &&
          props[exponent] in graph &&
          hex in graph[props[modulus]] &&
          dec